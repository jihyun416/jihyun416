---
layout: post
title:  NestJS - Pipes
author: Jihyun
category: nestjs
tags:
- nestjs
date: 2021-10-05 14:37 +0900
---

## Pipes

A pipe is a class annotated with the `@Injectable()` decorator. Pipes should implement the `PipeTransform` interface.

파이프는 `@Injectable()` 데코레이터로 주석이 달린 클래스입니다. 파이프는 `PipeTransform` 인터페이스를 구현해야 합니다.

![img](https://docs.nestjs.com/assets/Pipe_1.png)

Pipes have two typical use cases:

- **transformation**: transform input data to the desired form (e.g., from string to integer)
- **validation**: evaluate input data and if valid, simply pass it through unchanged; otherwise, throw an exception when the data is incorrect

In both cases, pipes operate on the `arguments` being processed by a [controller route handler](https://docs.nestjs.com/controllers#route-parameters). Nest interposes a pipe just before a method is invoked, and the pipe receives the arguments destined for the method and operates on them. Any transformation or validation operation takes place at that time, after which the route handler is invoked with any (potentially) transformed arguments.

Nest comes with a number of built-in pipes that you can use out-of-the-box. You can also build your own custom pipes. In this chapter, we'll introduce the built-in pipes and show how to bind them to route handlers. We'll then examine several custom-built pipes to show how you can build one from scratch.

파이프에는 두가지 일반적인 사용사례가 있습니다.

- **변환**(transformation): 입력 데이터를 원하는 형식으로 변환(예: 문자열에서 정수로)
- **유효성 검사**(validation): 입력 데이터를 평가하고 유효한 경우 변경하지 않고 전달합니다. 그렇지 않으면 데이터가 올바르지 않을 때 예외를 발생시킵니다.

두경우 모두 파이프는 [컨트롤러 라우트 핸들러](https://docs.nestjs.kr/controllers#route-parameters)가 처리하는 `인수(arguments)`에서 작동합니다. Nest는 메소드가 호출되기 직전에 파이프를 삽입하고 파이프는 메소드로 향하는 인수를 수신하고 이에 대해 작동합니다. 모든 변환 또는 유효성 검사 작업은 해당 시간에 발생하며 그 후 라우트 핸들러가(잠재적으로) 변환된 인수와 함께 호출됩니다.

Nest에는 기본적으로 사용할 수 있는 여러 내장된 파이프가 함께 제공됩니다. 고유한 커스텀 파이프를 만들 수도 있습니다. 이 장에서는 내장된 파이프를 소개하고 라우트 핸들러에 바인딩하는 방법을 보여줍니다. 그런 다음 몇가지 커스텀 파이프를 조사하여, 처음부터 빌드하는 방법을 보여줍니다.

> **HINT**
>
> Pipes run inside the exceptions zone. This means that when a Pipe throws an exception it is handled by the exceptions layer (global exceptions filter and any [exceptions filters](https://docs.nestjs.com/exception-filters) that are applied to the current context). Given the above, it should be clear that when an exception is thrown in a Pipe, no controller method is subsequently executed. This gives you a best-practice technique for validating data coming into the application from external sources at the system boundary.
>
> 파이프는 예외 영역내에서 실행됩니다. 이것은 파이프가 예외를 던질 때 예외 계층(전역 예외필터 및 현재 컨텍스트에 적용되는 모든 [예외필터](https://docs.nestjs.kr/exception-filters))에 의해 처리된다는 것을 의미합니다. 위의 내용을 고려할 때 파이프에서 예외가 발생하면 이후에 컨트롤러 메서드가 실행되지 않음을 분명히해야 합니다. 이는 시스템 경계의 외부 소스에서 애플리케이션으로 들어오는 데이터를 검증하기 위한 모범사례 기술을 제공합니다.



## Built-in pipes

Nest comes with eight pipes available out-of-the-box:

Nest에는 즉시 사용할 수 있는 6 개의 파이프가 함께 제공됩니다.

- `ValidationPipe`
- `ParseIntPipe`
- `ParseFloatPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`
- `ParseEnumPipe`
- `DefaultValuePipe`

They're exported from the `@nestjs/common` package.

Let's take a quick look at using `ParseIntPipe`. This is an example of the **transformation** use case, where the pipe ensures that a method handler parameter is converted to a JavaScript integer (or throws an exception if the conversion fails). Later in this chapter, we'll show a simple custom implementation for a `ParseIntPipe`. The example techniques below also apply to the other built-in transformation pipes (`ParseBoolPipe`, `ParseFloatPipe`, `ParseEnumPipe`, `ParseArrayPipe` and `ParseUUIDPipe`, which we'll refer to as the `Parse*` pipes in this chapter).

`@nestjs/common` 패키지에서 내보내집니다.

`ParseIntPipe` 사용에 대해 간단히 살펴 보겠습니다. 이것은 파이프가 메소드 핸들러 매개변수가 자바스크립트 정수로 변환되도록 하는 **변환** 사용 사례의 예입니다(또는 변환에 실패하면 예외가 발생함). 이 장의 뒷부분에서 `ParseIntPipe`에 대한 간단한 커스텀 구현을 보여줄 것입니다. 아래의 예제 기술은 다른 내장 변환 파이프에도 적용됩니다(`ParseBoolPipe`, `ParseArrayPipe` 및 `ParseUUIDPipe`, 이 장에서 `Parse*` 파이프라고 함).



## Binding pipes

To use a pipe, we need to bind an instance of the pipe class to the appropriate context. In our `ParseIntPipe` example, we want to associate the pipe with a particular route handler method, and make sure it runs before the method is called. We do so with the following construct, which we'll refer to as binding the pipe at the method parameter level:

파이프를 사용하려면 파이프 클래스의 인스턴스를 적절한 컨텍스트에 바인딩해야 합니다. `ParseIntPipe` 예제에서 파이프를 특정 라우트 핸들러 메소드와 연관시키고 메소드가 호출되기 전에 실행되는지 확인하려고 합니다. 메서드 매개변수 수준에서 파이프를 바인딩하는 것으로 참조할 다음 구성으로 이를 수행합니다.

```typescript
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

This ensures that one of the following two conditions is true: either the parameter we receive in the `findOne()` method is a number (as expected in our call to `this.catsService.findOne()`), or an exception is thrown before the route handler is called.

For example, assume the route is called like:

이렇게 하면 다음 두조건중 하나가 참이 됩니다. `findOne()` 메서드에서 수신하는 매개변수가 숫자(`this.catsService.findOne()` 호출에서 예상한대로)이거나 예외는 다음과 같습니다. 라우트 핸들러가 호출되기 전에 발생합니다.

예를 들어 라우터가 다음과 같이 호출되었다고 가정합니다.

```bash
GET localhost:3000/abc
```

Nest will throw an exception like this:

```json
{
  "statusCode": 400,
  "message": "Validation failed (numeric string is expected)",
  "error": "Bad Request"
}
```

The exception will prevent the body of the `findOne()` method from executing.

In the example above, we pass a class (`ParseIntPipe`), not an instance, leaving responsibility for instantiation to the framework and enabling dependency injection. As with pipes and guards, we can instead pass an in-place instance. Passing an in-place instance is useful if we want to customize the built-in pipe's behavior by passing options:

예외는 `findOne()` 메서드의 본문이 실행되지 않도록 합니다.

위의 예에서는 인스턴스가 아닌 클래스(`ParseIntPipe`)를 전달하여 인스턴스화를 프레임워크에 맡기고 종속성 주입을 활성화합니다. 파이프 및 가드와 마찬가지로 대신 내부 인스턴스를 전달할 수 있습니다. 내부(in-place) 인스턴스를 전달하는 것은 옵션을 전달하여 내장 파이프의 동작을 커스텀하려는 경우 유용합니다.

```typescript
@Get(':id')
async findOne(
  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))
  id: number,
) {
  return this.catsService.findOne(id);
}
```

Binding the other transformation pipes (all of the **Parse\*** pipes) works similarly. These pipes all work in the context of validating route parameters, query string parameters and request body values.

For example with a query string parameter:

다른 변환 파이프(모든 **Parse\*** 파이프)를 바인딩하는 방법도 비슷합니다. 이러한 파이프는 모두 라우트 매개변수, 쿼리 문자열 매개변수 및 요청 본문 값을 확인하는 컨텍스트에서 작동합니다.

예를 들어 쿼리 문자열 매개변수를 사용하는 경우:

```typescript
@Get()
async findOne(@Query('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

Here's an example of using the `ParseUUIDPipe` to parse a string parameter and validate if it is a UUID.

다음은 `ParseUUIDPipe`를 사용하여 문자열 매개변수를 구문분석하고 UUID인지 확인하는 예입니다.

```typescript
@Get(':uuid')
async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {
  return this.catsService.findOne(uuid);
}
```

> **HINT**
>
> When using `ParseUUIDPipe()` you are parsing UUID in version 3, 4 or 5, if you only require a specific version of UUID you can pass a version in the pipe options.
>
> `ParseUUIDPipe()`를 사용하는 경우 버전 3, 4 또는 5에서 UUID를 구문분석합니다. 특정 버전의 UUID만 필요한 경우 파이프 옵션에서 버전을 전달할 수 있습니다.

Above we've seen examples of binding the various `Parse*` family of built-in pipes. Binding validation pipes is a little bit different; we'll discuss that in the following section.

위에서 우리는 내장 파이프의 다양한 `Parse*` 계열을 바인딩하는 예를 보았습니다. 바인딩 유효성 검사 파이프는 약간 다릅니다. 다음 섹션에서 논의할 것입니다.

> **HINT**
>
> Also, see [Validation techniques](https://docs.nestjs.com/techniques/validation) for extensive examples of validation pipes.
>
> 또한 검증 파이프의 광범위한 예는 [검증기법](https://docs.nestjs.kr/techniques/validation)을 참조하십시오.



## Custom pipes

As mentioned, you can build your own custom pipes. While Nest provides a robust built-in `ParseIntPipe` and `ValidationPipe`, let's build simple custom versions of each from scratch to see how custom pipes are constructed.

We start with a simple `ValidationPipe`. Initially, we'll have it simply take an input value and immediately return the same value, behaving like an identity function.

언급했듯이 커스텀 파이프를 만들 수 있습니다. Nest는 강력한 내장 `ParseIntPipe` 및 `ValidationPipe`를 제공하지만, 각각의 간단한 커스텀 버전을 처음부터 만들어 커스텀 파이프가 어떻게 구성되는지 살펴 보겠습니다.

간단한 `ValidationPipe`로 시작합니다. 처음에는 단순히 입력값을 취하고 즉시 동일한 값을 반환하여 식별함수처럼 동작하도록 합니다.

### validation.pipe.ts

```typescript
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}
```

> **HINT**
>
> `PipeTransform<T, R>` is a generic interface that must be implemented by any pipe. The generic interface uses `T` to indicate the type of the input `value`, and `R` to indicate the return type of the `transform()` method.
>
> `PipeTransform<T, R>`은 파이프로 구현해야하는 일반 인터페이스입니다. 일반 인터페이스는 `T`를 사용하여 입력 `value`의 유형을 나타내고 `R`을 사용하여 `transform()`메서드의 반환유형을 나타냅니다.

Every pipe must implement the `transform()` method to fulfill the `PipeTransform` interface contract. This method has two parameters:

- `value`
- `metadata`

The `value` parameter is the currently processed method argument (before it is received by the route handling method), and `metadata` is the currently processed method argument's metadata. The metadata object has these properties:

모든 파이프는 `PipeTransform` 인터페이스 계약을 이행하기 위해 `transform()`메서드를 구현해야 합니다. 이 메소드에는 두개의 매개변수가 있습니다.

- `value`
- `metadata`

`value` 매개변수는 현재 처리된 메서드 인수(라우트 처리 메서드에 의해 수신되기 전)이고 `metadata`는 현재 처리된 메서드 인수의 메타데이터입니다. 메타데이터 객체에는 다음과 같은 속성이 있습니다.

```typescript
export interface ArgumentMetadata {
  type: 'body' | 'query' | 'param' | 'custom';
  metatype?: Type<unknown>;
  data?: string;
}
```

These properties describe the currently processed argument.

이러한 속성은 현재 처리된 인수를 설명합니다.

| `type`     | Indicates whether the argument is a body `@Body()`, query `@Query()`, param `@Param()`, or a custom parameter (read more [here](https://docs.nestjs.com/custom-decorators)). | 인수가 본문 `@Body()`, 쿼리 `@Query()`, param `@Param()` 또는 커스텀 매개변수인지 여부를 나타냅니다(자세한 내용은 [여기](https://docs.nestjs.kr/custom-decorators)) 참조). |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `metatype` | Provides the metatype of the argument, for example, `String`. Note: the value is `undefined` if you either omit a type declaration in the route handler method signature, or use vanilla JavaScript. | 인수의 메타타입을 제공합니다(예: `String`). 참고: 라우트 핸들러 메소드 서명에서 타입 선언을 생략하거나 바닐라 자바스크립트를 사용하면 값이 `정의되지 않습니다`. |
| `data`     | The string passed to the decorator, for example `@Body('string')`. It's `undefined` if you leave the decorator parenthesis empty. | 데코레이터에 전달된 문자열(예: `@Body('string')`). 데코레이터 괄호를 비워두면 `정의되지 않습니다`. |

> **WARNING**
>
> TypeScript interfaces disappear during transpilation. Thus, if a method parameter's type is declared as an interface instead of a class, the `metatype` value will be `Object`.
>
> TypeScript 인터페이스는 변환중에 사라집니다. 따라서 메소드 매개변수의 타입이 클래스가 아닌 인터페이스로 선언되면 `metatype`값은 `Object`가 됩니다.



## Schema based validation

Let's make our validation pipe a little more useful. Take a closer look at the `create()` method of the `CatsController`, where we probably would like to ensure that the post body object is valid before attempting to run our service method.

유효성 검사 파이프를 좀 더 유용하게 만들어 보겠습니다. `CatsController`의 `create()` 메소드를 자세히 살펴보면 서비스 메소드를 실행하기 전에 게시물 본문 객체가 유효한지 확인하고 싶을 것입니다.

```typescript
@Post()
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

Let's focus in on the `createCatDto` body parameter. Its type is `CreateCatDto`:

`createCatDto` 본문 매개변수에 초점을 맞춥니다. 타입은 `CreateCatDto`입니다.

### create-cat.dto.ts

```typescript
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}
```

We want to ensure that any incoming request to the create method contains a valid body. So we have to validate the three members of the `createCatDto` object. We could do this inside the route handler method, but doing so is not ideal as it would break the **single responsibility rule** (SRP).

Another approach could be to create a **validator class** and delegate the task there. This has the disadvantage that we would have to remember to call this validator at the beginning of each method.

How about creating validation middleware? This could work, but unfortunately it's not possible to create **generic middleware** which can be used across all contexts across the whole application. This is because middleware is unaware of the **execution context**, including the handler that will be called and any of its parameters.

This is, of course, exactly the use case for which pipes are designed. So let's go ahead and refine our validation pipe.

create 메서드로 들어오는 모든 요청에 유효한 본문이 포함되어 있는지 확인하고 싶습니다. 그래서 우리는 `createCatDto` 객체의 세 멤버를 검증해야 합니다. 라우트 핸들러 메소드내에서 이를 수행할 수 있지만 그렇게 하는 것은 **단일 책임 규칙**(SRP single responsibility rule)을 위반하므로 이상적이지 않습니다.

또 다른 접근방식은 **유효성 검사기 클래스**를 만들고 여기에 작업을 위임하는 것입니다. 이것은 우리가 각 메서드의 시작부분에서 이 유효성 검사기를 호출해야 한다는 것을 기억해야 한다는 단점이 있습니다.

유효성 검사 미들웨어를 만드는 것은 어떻습니까? 이것은 작동할 수 있지만 불행히도 전체 애플리케이션의 모든 컨텍스트에서 사용할 수 있는 **일반 미들웨어**를 만드는 것은 불가능합니다. 이는 미들웨어가 호출될 핸들러 및 매개변수를 포함하여 **실행 컨텍스트**를 인식하지 못하기 때문입니다.

물론 이것은 파이프가 설계된 사용사례입니다. 이제 계속해서 검증 파이프를 개선해 보겠습니다.



## Object schema validation

There are several approaches available for doing object validation in a clean, [DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself) way. One common approach is to use **schema-based** validation. Let's go ahead and try that approach.

The [Joi](https://github.com/sideway/joi) library allows you to create schemas in a straightforward way, with a readable API. Let's build a validation pipe that makes use of Joi-based schemas.

Start by installing the required package:

깨끗하고 [건조한](https://en.wikipedia.org/wiki/Don't_repeat_yourself) 방식으로 객체 유효성 검사를 수행하는데 사용할 수 있는 몇가지 방법이 있습니다. 한가지 일반적인 접근 방식은 **스키마 기반** 유효성 검사를 사용하는 것입니다. 계속해서 그 접근방식을 시도해 봅시다.

[Joi](https://github.com/sideway/joi) 라이브러리를 사용하면 읽기 쉬운 API를 사용하여 간단한 방식으로 스키마를 만들 수 있습니다. Joi 기반 스키마를 사용하는 유효성 검사 파이프를 구축해 보겠습니다.

필요한 패키지를 설치하여 시작하십시오.

```bash
$ npm install --save joi
$ npm install --save-dev @types/joi
```

In the code sample below, we create a simple class that takes a schema as a `constructor` argument. We then apply the `schema.validate()` method, which validates our incoming argument against the provided schema.

As noted earlier, a **validation pipe** either returns the value unchanged, or throws an exception.

In the next section, you'll see how we supply the appropriate schema for a given controller method using the `@UsePipes()` decorator. Doing so makes our validation pipe re-usable across contexts, just as we set out to do.

앞서 `ParseIntPipe` 및 나머지 `Parse*` 파이프와 같은 변환 파이프를 바인딩하는 방법을 살펴 보았습니다.

바인딩 유효성 검사 파이프도 매우 간단합니다.

이 경우 메서드 호출 수준에서 파이프를 바인딩하려고 합니다. 현재 예제에서 `JoiValidationPipe`를 사용하려면 다음을 수행해야 합니다.

1. `JoiValidationPipe`의 인스턴스를 만듭니다.
2. 파이프의 클래스 생성자에 컨텍스트별 Joi 스키마를 전달합니다.
3. 파이프를 메서드에 바인딩

아래와 같이 `@UsePipes()` 데코레이터를 사용합니다.

```typescript
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { ObjectSchema } from 'joi';

@Injectable()
export class JoiValidationPipe implements PipeTransform {
  constructor(private schema: ObjectSchema) {}

  transform(value: any, metadata: ArgumentMetadata) {
    const { error } = this.schema.validate(value);
    if (error) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }
}
```



## Binding validation pipes

Earlier, we saw how to bind transformation pipes (like `ParseIntPipe` and the rest of the `Parse*` pipes).

Binding validation pipes is also very straightforward.

In this case, we want to bind the pipe at the method call level. In our current example, we need to do the following to use the `JoiValidationPipe`:

1. Create an instance of the `JoiValidationPipe`
2. Pass the context-specific Joi schema in the class constructor of the pipe
3. Bind the pipe to the method

We do that using the `@UsePipes()` decorator as shown below:

앞서 `ParseIntPipe` 및 나머지 `Parse*` 파이프와 같은 변환 파이프를 바인딩하는 방법을 살펴 보았습니다.

바인딩 유효성 검사 파이프도 매우 간단합니다.

이 경우 메서드 호출 수준에서 파이프를 바인딩하려고 합니다. 현재 예제에서 `JoiValidationPipe`를 사용하려면 다음을 수행해야 합니다.

1. `JoiValidationPipe`의 인스턴스를 만듭니다.
2. 파이프의 클래스 생성자에 컨텍스트별 Joi 스키마를 전달합니다.
3. 파이프를 메서드에 바인딩

아래와 같이 `@UsePipes()` 데코레이터를 사용합니다.

```typescript
@Post()
@UsePipes(new JoiValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

> **HINT**
>
> The `@UsePipes()` decorator is imported from the `@nestjs/common` package.
>
> `@UsePipes()` 데코레이터는 `@nestjs/common` 패키지에서 가져옵니다.



## Class validator

> **WARNING**
>
> The techniques in this section require TypeScript, and are not available if your app is written using vanilla JavaScript.
>
> 이 섹션의 기술에는 TypeScript가 필요하며 앱이 바닐라 자바스크립트를 사용하여 작성된 경우 사용할 수 없습니다.

Let's look at an alternate implementation for our validation technique.

Nest works well with the [class-validator](https://github.com/typestack/class-validator) library. This powerful library allows you to use decorator-based validation. Decorator-based validation is extremely powerful, especially when combined with Nest's **Pipe** capabilities since we have access to the `metatype` of the processed property. Before we start, we need to install the required packages:

유효성 검사 기술의 대체 구현을 살펴 보겠습니다.

Nest는 [class-validator](https://github.com/typestack/class-validator) 라이브러리와 잘 작동합니다. 이 강력한 라이브러리를 사용하면 데코레이터 기반 유효성 검사를 사용할 수 있습니다. 데코레이터 기반 유효성 검사는 특히 처리된 속성의 `metatype`에 액세스할 수 있으므로 Nest의 **파이프** 기능과 결합할 때 매우 강력합니다. 시작하기 전에 필요한 패키지를 설치해야 합니다.

```bash
$ npm i --save class-validator class-transformer
```

Once these are installed, we can add a few decorators to the `CreateCatDto` class. Here we see a significant advantage of this technique: the `CreateCatDto` class remains the single source of truth for our Post body object (rather than having to create a separate validation class).

이것들이 설치되면 `CreateCatDto` 클래스에 데코레이터 몇개를 추가할 수 있습니다. 여기에서 이 기법의 중요한 이점을 볼 수 있습니다.`CreateCatDto` 클래스는 Post 본문 객체에 대한 단일 소스로 남아 있습니다 (별도의 유효성 검사 클래스를 만들 필요가 없음).

### create-cat.dto.ts

```typescript
import { IsString, IsInt } from 'class-validator';

export class CreateCatDto {
  @IsString()
  name: string;

  @IsInt()
  age: number;

  @IsString()
  breed: string;
}
```

> **HINT**
>
> Read more about the class-validator decorators [here](https://github.com/typestack/class-validator#usage).
> 클래스 유효성 검사기 데코레이터에 대한 자세한 내용은 [여기](https://github.com/typestack/class-validator#usage)를 참조하세요.

Now we can create a `ValidationPipe` class that uses these annotations.

이제 이러한 주석을 사용하는 `ValidationPipe` 클래스를 만들 수 있습니다.

### validation.pipe.ts

```typescript
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { validate } from 'class-validator';
import { plainToClass } from 'class-transformer';

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToClass(metatype, value);
    const errors = await validate(object);
    if (errors.length > 0) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metatype);
  }
}
```

> **NOTICE**
>
> Above, we have used the [class-transformer](https://github.com/typestack/class-transformer) library. It's made by the same author as the **class-validator** library, and as a result, they play very well together.
>
> 위에서 우리는 [class-transformer](https://github.com/typestack/class-transformer) 라이브러리를 사용했습니다. **class-validator** 라이브러리와 동일한 작성자가 만들었으며 결과적으로 서로 잘 어울립니다.

Let's go through this code. First, note that the `transform()` method is marked as `async`. This is possible because Nest supports both synchronous and **asynchronous** pipes. We make this method `async` because some of the class-validator validations [can be async](https://github.com/typestack/class-validator#custom-validation-classes) (utilize Promises).

Next note that we are using destructuring to extract the metatype field (extracting just this member from an `ArgumentMetadata`) into our `metatype` parameter. This is just shorthand for getting the full `ArgumentMetadata` and then having an additional statement to assign the metatype variable.

Next, note the helper function `toValidate()`. It's responsible for bypassing the validation step when the current argument being processed is a native JavaScript type (these can't have validation decorators attached, so there's no reason to run them through the validation step).

Next, we use the class-transformer function `plainToClass()` to transform our plain JavaScript argument object into a typed object so that we can apply validation. The reason we must do this is that the incoming post body object, when deserialized from the network request, does **not have any type information** (this is the way the underlying platform, such as Express, works). Class-validator needs to use the validation decorators we defined for our DTO earlier, so we need to perform this transformation to treat the incoming body as an appropriately decorated object, not just a plain vanilla object.

Finally, as noted earlier, since this is a **validation pipe** it either returns the value unchanged, or throws an exception.

The last step is to bind the `ValidationPipe`. Pipes can be parameter-scoped, method-scoped, controller-scoped, or global-scoped. Earlier, with our Joi-based validation pipe, we saw an example of binding the pipe at the method level. In the example below, we'll bind the pipe instance to the route handler `@Body()` decorator so that our pipe is called to validate the post body.

이 코드를 살펴보겠습니다. 먼저 `transform()` 메서드가 `async`로 표시되어 있습니다. Nest가 동기 및 **비동기** 파이프를 모두 지원하기 때문에 가능합니다. 일부 `class-validator` 유효성 검사가 [비동기화될 수 있음](https://github.com/typestack/class-validator#custom-validation-classes)(Promise 활용)때문에 이 메서드를 `async`로 만듭니다.

다음으로, 우리는 메타타입 필드 (`ArgumentMetadata`에서 이 멤버만 추출)를 `metatype` 매개변수로 추출하기 위해 디스트럭처링을 사용하고 있습니다. 이것은 전체 `ArgumentMetadata`를 가져온 다음 메타타입 변수를 할당하는 추가 명령문을 갖는 것에 대한 속기일 뿐입니다.

다음으로 헬퍼 함수 `toValidate()`를 확인합니다. 처리중인 현재 인수가 네이티브 자바스크립트 타입인 경우 유효성 검사 단계를 건너 뛰는 역할을 합니다(이러한 인수는 유효성 검사 데코레이터를 연결할 수 없으므로 유효성 검사 단계를 통해 실행할 이유가 없습니다).

다음으로 클래스 변환기 함수 `plainToClass()`를 사용하여 일반 자바스크립트 인수 객체를 타입이 지정된 객체로 변환하여 유효성 검사를 적용할 수 있습니다. 이 작업을 수행해야 하는 이유는 네트워크 요청에서 역직렬화될 때 들어오는 포스트(post) 본문 객체가 **아무 타입 정보도 가지고 있지 않기 때문입니다**(이것이 Express와 같은 기본 플랫폼이 작동하는 방식입니다). 클래스 유효성 검사기는 이전에 DTO에 대해 정의한 유효성 검사 데코레이터를 사용해야 하므로 들어오는 본문을 단순한 바닐라 객체가 아닌 적절하게 장식된 객체로 처리하기 위해 이 변환을 수행해야 합니다.

마지막으로 앞서 언급했듯이 이것은 **유효성 검사 파이프**이므로 변경되지 않은 값을 반환하거나 예외를 던집니다(throw).

마지막 단계는 `ValidationPipe`를 바인딩하는 것입니다. 파이프는 매개변수 범위, 메서드 범위, 컨트롤러 범위 또는 전역 범위일 수 있습니다. 앞서 Joi 기반 유효성 검사 파이프를 사용하여 메서드 수준에서 파이프를 바인딩하는 예를 보았습니다. 아래 예제에서는 파이프 인스턴스를 라우트 핸들러 `@Body()` 데코레이터에 바인딩하여 파이프가 포스트(post) 본문의 유효성을 검사하도록 호출합니다.

### cats.controller.ts

```typescript
@Post()
async create(
  @Body(new ValidationPipe()) createCatDto: CreateCatDto,
) {
  this.catsService.create(createCatDto);
}
```

Parameter-scoped pipes are useful when the validation logic concerns only one specified parameter.

매개변수 범위 파이프는 유효성 검증 로직이 지정된 매개변수 하나만 관련될 때 유용합니다.



## Global scoped pipes

Since the `ValidationPipe` was created to be as generic as possible, we can realize it's full utility by setting it up as a **global-scoped** pipe so that it is applied to every route handler across the entire application.

`ValidationPipe`는 가능한 한 일반적으로 생성되었으므로 전체 애플리케이션의 모든 라우트 핸들러에 적용되도록 **전역 범위**(global-scoped) 파이프로 설정하여 완전한 유틸리티임을 실현할 수 있습니다.

### main.ts

```typescript
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
bootstrap();
```

> **NOTICE**
>
> In the case of [hybrid apps](https://docs.nestjs.com/faq/hybrid-application) the `useGlobalPipes()` method doesn't set up pipes for gateways and micro services. For "standard" (non-hybrid) microservice apps, `useGlobalPipes()` does mount pipes globally.
>
> [하이브리드 앱](https://docs.nestjs.kr/faq/hybrid-application)의 경우 `useGlobalPipes()` 메서드는 게이트웨이 및 마이크로서비스에 대한 파이프를 설정하지 않습니다. "표준"(비 하이브리드) 마이크로서비스 앱의 경우 `useGlobalPipes()`는 파이프를 전역으로 마운트합니다.

Global pipes are used across the whole application, for every controller and every route handler.

Note that in terms of dependency injection, global pipes registered from outside of any module (with `useGlobalPipes()` as in the example above) cannot inject dependencies since the binding has been done outside the context of any module. In order to solve this issue, you can set up a global pipe **directly from any module** using the following construction:

전역 파이프는 모든 컨트롤러 및 모든 라우트 핸들러에 대해 애플리케이션에서 사용됩니다.

의존성 주입과 관련하여 모듈 외부에서 등록된 전역 파이프(위의 예에서와 같이 `useGlobalPipes()` 사용)는 바인딩이 모듈 컨텍스트 외부에서 수행되었으므로 종속성을 주입할 수 없습니다. 이 문제를 해결하기 위해 다음 구성을 사용하여 **모든 모듈에서 직접** 전역 파이프를 설정할 수 있습니다.

### app.module.ts

```typescript
import { Module } from '@nestjs/common';
import { APP_PIPE } from '@nestjs/core';

@Module({
  providers: [
    {
      provide: APP_PIPE,
      useClass: ValidationPipe,
    },
  ],
})
export class AppModule {}
```

> **HINT**
>
> When using this approach to perform dependency injection for the pipe, note that regardless of the module where this construction is employed, the pipe is, in fact, global. Where should this be done? Choose the module where the pipe (`ValidationPipe` in the example above) is defined. Also, `useClass` is not the only way of dealing with custom provider registration. Learn more [here](https://docs.nestjs.com/fundamentals/custom-providers).
>
> 이 접근방식을 사용하여 파이프에 대한 종속성 주입을 수행할 때 이 구성이 사용되는 모듈에 관계없이 파이프는 실제로 전역이라는 점에 유의하십시오. 어디에서해야 합니까? 파이프(위의 예에서는 `ValidationPipe`)가 정의된 모듈을 선택합니다. 또한 `useClass`가 커스텀 프로바이더 등록을 처리하는 유일한 방법은 아닙니다. [여기](https://docs.nestjs.kr/fundamentals/custom-providers)에서 자세히 알아보세요.



## The built-in ValidationPipe

As a reminder, you don't have to build a generic validation pipe on your own since the `ValidationPipe` is provided by Nest out-of-the-box. The built-in `ValidationPipe` offers more options than the sample we built in this chapter, which has been kept basic for the sake of illustrating the mechanics of a custom-built pipe. You can find full details, along with lots of examples [here](https://docs.nestjs.com/techniques/validation).

참고로 `ValidationPipe`는 Nest에서 즉시 제공되므로 일반 유효성 검사 파이프를 직접 빌드할 필요가 없습니다. 빌트인 `ValidationPipe`는 이 장에서 빌드한 샘플보다 더 많은 옵션을 제공합니다. 이 샘플은 커스텀 빌드 파이프의 메커니즘을 설명하기 위해 기본으로 유지되었습니다. 많은 예제와 함께 자세한 내용은 [여기](https://docs.nestjs.kr/techniques/validation)에서 찾을 수 있습니다.



## Transformation use case

Validation isn't the only use case for custom pipes. At the beginning of this chapter, we mentioned that a pipe can also **transform** the input data to the desired format. This is possible because the value returned from the `transform` function completely overrides the previous value of the argument.

When is this useful? Consider that sometimes the data passed from the client needs to undergo some change - for example converting a string to an integer - before it can be properly handled by the route handler method. Furthermore, some required data fields may be missing, and we would like to apply default values. **Transformation pipes** can perform these functions by interposing a processing function between the client request and the request handler.

Here's a simple `ParseIntPipe` which is responsible for parsing a string into an integer value. (As noted above, Nest has a built-in `ParseIntPipe` that is more sophisticated; we include this as a simple example of a custom transformation pipe).

커스텀 파이프의 유일한 사용 사례는 유효성 검사가 아닙니다. 이 장의 시작부분에서 파이프가 입력 데이터를 원하는 형식으로 **변환**할 수도 있다고 언급했습니다. 이는 `transform` 함수에서 반환된 값이 인수의 이전값을 완전히 덮어쓰기 때문에 가능합니다.

이것이 언제 유용합니까? 때때로 클라이언트에서 전달된 데이터는 라우트 핸들러 메소드에 의해 적절하게 처리되기 전에 문자열을 정수로 변환하는 것과 같이 약간의 변경이 필요하다는 점을 고려하십시오. 또한 일부 필수 데이터 필드가 누락되었을 수 있으며 기본값을 적용하려고합니다. **변환 파이프**는 클라이언트 요청과 요청 핸들러 사이에 처리 기능을 삽입하여 이러한 기능을 수행할 수 있습니다.

다음은 문자열을 정수값으로 파싱하는 간단한 `ParseIntPipe`입니다.(위에서 언급했듯이 Nest에는 더 정교한 내장 `ParseIntPipe`가 있습니다. 이를 커스텀 변환 파이프의 간단한 예로 포함합니다).

### parse-int.pipe.ts

```typescript
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';

@Injectable()
export class ParseIntPipe implements PipeTransform<string, number> {
  transform(value: string, metadata: ArgumentMetadata): number {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed');
    }
    return val;
  }
}
```

We can then bind this pipe to the selected param as shown below:

그런 다음 이 파이프를 아래와 같이 선택한 매개변수에 바인딩할 수 있습니다.

```typescript
@Get(':id')
async findOne(@Param('id', new ParseIntPipe()) id) {
  return this.catsService.findOne(id);
}
```

Another useful transformation case would be to select an **existing user** entity from the database using an id supplied in the request:

[![ads via Carbon](https://cdn4.buysellads.net/uu/1/3386/1525189943-38523.png)](https://srv.carbonads.net/ads/click/x/GTND42JICK7IL2JICWBLYKQNCK7IP23UCEADPZ3JCY7IC2QJFT7IE23KCASIT2JNCYAIV2JEFTSD4237F6AIK2QKC6SDCK7WC6YDTK3EHJNCLSIZ?segment=placement:nestjscom;)[Limited time offer: Get 10 free Adobe Stock images.](https://srv.carbonads.net/ads/click/x/GTND42JICK7IL2JICWBLYKQNCK7IP23UCEADPZ3JCY7IC2QJFT7IE23KCASIT2JNCYAIV2JEFTSD4237F6AIK2QKC6SDCK7WC6YDTK3EHJNCLSIZ?segment=placement:nestjscom;)[ADS VIA CARBON](http://carbonads.net/?utm_source=nestjscom&utm_medium=ad_via_link&utm_campaign=in_unit&utm_term=carbon)



### Pipes

파이프는 `@Injectable()` 데코레이터로 주석이 달린 클래스입니다. 파이프는 `PipeTransform` 인터페이스를 구현해야 합니다.

![img](https://docs.nestjs.kr/assets/Pipe_1.png)

파이프에는 두가지 일반적인 사용사례가 있습니다.

- **변환**(transformation): 입력 데이터를 원하는 형식으로 변환(예: 문자열에서 정수로)
- **유효성 검사**(validation): 입력 데이터를 평가하고 유효한 경우 변경하지 않고 전달합니다. 그렇지 않으면 데이터가 올바르지 않을 때 예외를 발생시킵니다.

두경우 모두 파이프는 [컨트롤러 라우트 핸들러](https://docs.nestjs.kr/controllers#route-parameters)가 처리하는 `인수(arguments)`에서 작동합니다. Nest는 메소드가 호출되기 직전에 파이프를 삽입하고 파이프는 메소드로 향하는 인수를 수신하고 이에 대해 작동합니다. 모든 변환 또는 유효성 검사 작업은 해당 시간에 발생하며 그 후 라우트 핸들러가(잠재적으로) 변환된 인수와 함께 호출됩니다.

Nest에는 기본적으로 사용할 수 있는 여러 내장된 파이프가 함께 제공됩니다. 고유한 커스텀 파이프를 만들 수도 있습니다. 이 장에서는 내장된 파이프를 소개하고 라우트 핸들러에 바인딩하는 방법을 보여줍니다. 그런 다음 몇가지 커스텀 파이프를 조사하여, 처음부터 빌드하는 방법을 보여줍니다.

> **힌트**파이프는 예외 영역내에서 실행됩니다. 이것은 파이프가 예외를 던질 때 예외 계층(전역 예외필터 및 현재 컨텍스트에 적용되는 모든 [예외필터](https://docs.nestjs.kr/exception-filters))에 의해 처리된다는 것을 의미합니다. 위의 내용을 고려할 때 파이프에서 예외가 발생하면 이후에 컨트롤러 메서드가 실행되지 않음을 분명히해야 합니다. 이는 시스템 경계의 외부 소스에서 애플리케이션으로 들어오는 데이터를 검증하기 위한 모범사례 기술을 제공합니다.

#### Built-in pipes[#](https://docs.nestjs.kr/pipes#built-in-pipes)

Nest에는 즉시 사용할 수 있는 6 개의 파이프가 함께 제공됩니다.

- `ValidationPipe`
- `ParseIntPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`
- `DefaultValuePipe`

`@nestjs/common` 패키지에서 내보내집니다.

`ParseIntPipe` 사용에 대해 간단히 살펴 보겠습니다. 이것은 파이프가 메소드 핸들러 매개변수가 자바스크립트 정수로 변환되도록 하는 **변환** 사용 사례의 예입니다(또는 변환에 실패하면 예외가 발생함). 이 장의 뒷부분에서 `ParseIntPipe`에 대한 간단한 커스텀 구현을 보여줄 것입니다. 아래의 예제 기술은 다른 내장 변환 파이프에도 적용됩니다(`ParseBoolPipe`, `ParseArrayPipe` 및 `ParseUUIDPipe`, 이 장에서 `Parse*` 파이프라고 함).

#### Binding pipes[#](https://docs.nestjs.kr/pipes#binding-pipes)

파이프를 사용하려면 파이프 클래스의 인스턴스를 적절한 컨텍스트에 바인딩해야 합니다. `ParseIntPipe` 예제에서 파이프를 특정 라우트 핸들러 메소드와 연관시키고 메소드가 호출되기 전에 실행되는지 확인하려고 합니다. 메서드 매개변수 수준에서 파이프를 바인딩하는 것으로 참조할 다음 구성으로 이를 수행합니다.

```typescript
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

이렇게 하면 다음 두조건중 하나가 참이 됩니다. `findOne()` 메서드에서 수신하는 매개변수가 숫자(`this.catsService.findOne()` 호출에서 예상한대로)이거나 예외는 다음과 같습니다. 라우트 핸들러가 호출되기 전에 발생합니다.

예를 들어 라우터가 다음과 같이 호출되었다고 가정합니다.

```bash
GET localhost:3000/abc
{
  "statusCode": 400,
  "message": "Validation failed (numeric string is expected)",
  "error": "Bad Request"
}
```

예외는 `findOne()` 메서드의 본문이 실행되지 않도록 합니다.

위의 예에서는 인스턴스가 아닌 클래스(`ParseIntPipe`)를 전달하여 인스턴스화를 프레임워크에 맡기고 종속성 주입을 활성화합니다. 파이프 및 가드와 마찬가지로 대신 내부 인스턴스를 전달할 수 있습니다. 내부(in-place) 인스턴스를 전달하는 것은 옵션을 전달하여 내장 파이프의 동작을 커스텀하려는 경우 유용합니다.

```typescript
@Get(':id')
async findOne(
  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))
  id: number,
) {
  return this.catsService.findOne(id);
}
```

다른 변환 파이프(모든 **Parse\*** 파이프)를 바인딩하는 방법도 비슷합니다. 이러한 파이프는 모두 라우트 매개변수, 쿼리 문자열 매개변수 및 요청 본문 값을 확인하는 컨텍스트에서 작동합니다.

예를 들어 쿼리 문자열 매개변수를 사용하는 경우:

```typescript
@Get()
async findOne(@Query('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

다음은 `ParseUUIDPipe`를 사용하여 문자열 매개변수를 구문분석하고 UUID인지 확인하는 예입니다.

JS

```typescript
@Get(':uuid')
async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {
  return this.catsService.findOne(uuid);
}
```

> **힌트**`ParseUUIDPipe()`를 사용하는 경우 버전 3, 4 또는 5에서 UUID를 구문분석합니다. 특정 버전의 UUID만 필요한 경우 파이프 옵션에서 버전을 전달할 수 있습니다.

위에서 우리는 내장 파이프의 다양한 `Parse*` 계열을 바인딩하는 예를 보았습니다. 바인딩 유효성 검사 파이프는 약간 다릅니다. 다음 섹션에서 논의할 것입니다.

> **힌트**또한 검증 파이프의 광범위한 예는 [검증기법](https://docs.nestjs.kr/techniques/validation)을 참조하십시오.

#### Custom pipes[#](https://docs.nestjs.kr/pipes#custom-pipes)

언급했듯이 커스텀 파이프를 만들 수 있습니다. Nest는 강력한 내장 `ParseIntPipe` 및 `ValidationPipe`를 제공하지만, 각각의 간단한 커스텀 버전을 처음부터 만들어 커스텀 파이프가 어떻게 구성되는지 살펴 보겠습니다.

간단한 `ValidationPipe`로 시작합니다. 처음에는 단순히 입력값을 취하고 즉시 동일한 값을 반환하여 식별함수처럼 동작하도록 합니다.

validation.pipe.tsJS

```typescript
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}
```

> **힌트**`PipeTransform<T, R>`은 파이프로 구현해야하는 일반 인터페이스입니다. 일반 인터페이스는 `T`를 사용하여 입력 `value`의 유형을 나타내고 `R`을 사용하여 `transform()`메서드의 반환유형을 나타냅니다.

모든 파이프는 `PipeTransform` 인터페이스 계약을 이행하기 위해 `transform()`메서드를 구현해야 합니다. 이 메소드에는 두개의 매개변수가 있습니다.

- `value`
- `metadata`

`value` 매개변수는 현재 처리된 메서드 인수(라우트 처리 메서드에 의해 수신되기 전)이고 `metadata`는 현재 처리된 메서드 인수의 메타데이터입니다. 메타데이터 객체에는 다음과 같은 속성이 있습니다.

```typescript
export interface ArgumentMetadata {
  type: 'body' | 'query' | 'param' | 'custom';
  metatype?: Type<unknown>;
  data?: string;
}
```

이러한 속성은 현재 처리된 인수를 설명합니다.

| `type`     | 인수가 본문 `@Body()`, 쿼리 `@Query()`, param `@Param()` 또는 커스텀 매개변수인지 여부를 나타냅니다(자세한 내용은 [여기](https://docs.nestjs.kr/custom-decorators)) 참조). |
| ---------- | ------------------------------------------------------------ |
| `metatype` | 인수의 메타타입을 제공합니다(예: `String`). 참고: 라우트 핸들러 메소드 서명에서 타입 선언을 생략하거나 바닐라 자바스크립트를 사용하면 값이 `정의되지 않습니다`. |
| `data`     | 데코레이터에 전달된 문자열(예: `@Body('string')`). 데코레이터 괄호를 비워두면 `정의되지 않습니다`. |

> **경고**TypeScript 인터페이스는 변환중에 사라집니다. 따라서 메소드 매개변수의 타입이 클래스가 아닌 인터페이스로 선언되면 `metatype`값은 `Object`가 됩니다.

#### Schema based validation[#](https://docs.nestjs.kr/pipes#schema-based-validation)

유효성 검사 파이프를 좀 더 유용하게 만들어 보겠습니다. `CatsController`의 `create()` 메소드를 자세히 살펴보면 서비스 메소드를 실행하기 전에 게시물 본문 객체가 유효한지 확인하고 싶을 것입니다.

JS

```typescript
@Post()
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

`createCatDto` 본문 매개변수에 초점을 맞춥니다. 타입은 `CreateCatDto`입니다.

create-cat.dto.tsJS

```typescript
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}
```

create 메서드로 들어오는 모든 요청에 유효한 본문이 포함되어 있는지 확인하고 싶습니다. 그래서 우리는 `createCatDto` 객체의 세 멤버를 검증해야 합니다. 라우트 핸들러 메소드내에서 이를 수행할 수 있지만 그렇게 하는 것은 **단일 책임 규칙**(SRP single responsibility rule)을 위반하므로 이상적이지 않습니다.

또 다른 접근방식은 **유효성 검사기 클래스**를 만들고 여기에 작업을 위임하는 것입니다. 이것은 우리가 각 메서드의 시작부분에서 이 유효성 검사기를 호출해야 한다는 것을 기억해야 한다는 단점이 있습니다.

유효성 검사 미들웨어를 만드는 것은 어떻습니까? 이것은 작동할 수 있지만 불행히도 전체 애플리케이션의 모든 컨텍스트에서 사용할 수 있는 **일반 미들웨어**를 만드는 것은 불가능합니다. 이는 미들웨어가 호출될 핸들러 및 매개변수를 포함하여 **실행 컨텍스트**를 인식하지 못하기 때문입니다.

물론 이것은 파이프가 설계된 사용사례입니다. 이제 계속해서 검증 파이프를 개선해 보겠습니다.



## Learn the right way!

-  80+ chapters
-  5+ hours of videos
-  Official certificate
-  Deep-dive sessions

[EXPLORE OFFICIAL COURSES](https://courses.nestjs.com/)



#### Object schema validation[#](https://docs.nestjs.kr/pipes#object-schema-validation)

깨끗하고 [건조한](https://en.wikipedia.org/wiki/Don't_repeat_yourself) 방식으로 객체 유효성 검사를 수행하는데 사용할 수 있는 몇가지 방법이 있습니다. 한가지 일반적인 접근 방식은 **스키마 기반** 유효성 검사를 사용하는 것입니다. 계속해서 그 접근방식을 시도해 봅시다.

[Joi](https://github.com/sideway/joi) 라이브러리를 사용하면 읽기 쉬운 API를 사용하여 간단한 방식으로 스키마를 만들 수 있습니다. Joi 기반 스키마를 사용하는 유효성 검사 파이프를 구축해 보겠습니다.

필요한 패키지를 설치하여 시작하십시오.

```bash
$ npm install --save joi
$ npm install --save-dev @types/joi
```

아래 코드 샘플에서는 스키마를 `constructor` 인수로 사용하는 간단한 클래스를 만듭니다. 그런 다음 제공된 스키마에 대해 들어오는 인수의 유효성을 검사하는 `schema.validate()` 메서드를 적용합니다.

앞서 언급했듯이 **유효성 검사 파이프**는 값을 변경하지 않고 반환하거나 예외를 던집니다(throw).

다음 섹션에서는 `@UsePipes()` 데코레이터를 사용하여 주어진 컨트롤러 메소드에 적절한 스키마를 제공하는 방법을 볼 수 있습니다. 이렇게 하면 검증 파이프를 컨텍스트 전체에서 다시 사용할 수 있습니다.

JS

```typescript
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { ObjectSchema } from 'joi';

@Injectable()
export class JoiValidationPipe implements PipeTransform {
  constructor(private schema: ObjectSchema) {}

  transform(value: any, metadata: ArgumentMetadata) {
    const { error } = this.schema.validate(value);
    if (error) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }
}
```

#### Binding validation pipes[#](https://docs.nestjs.kr/pipes#binding-validation-pipes)

앞서 `ParseIntPipe` 및 나머지 `Parse*` 파이프와 같은 변환 파이프를 바인딩하는 방법을 살펴 보았습니다.

바인딩 유효성 검사 파이프도 매우 간단합니다.

이 경우 메서드 호출 수준에서 파이프를 바인딩하려고 합니다. 현재 예제에서 `JoiValidationPipe`를 사용하려면 다음을 수행해야 합니다.

1. `JoiValidationPipe`의 인스턴스를 만듭니다.
2. 파이프의 클래스 생성자에 컨텍스트별 Joi 스키마를 전달합니다.
3. 파이프를 메서드에 바인딩

아래와 같이 `@UsePipes()` 데코레이터를 사용합니다.

JS

```typescript
@Post()
@UsePipes(new JoiValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

> **힌트**`@UsePipes()` 데코레이터는 `@nestjs/common` 패키지에서 가져옵니다.

#### Class validator[#](https://docs.nestjs.kr/pipes#class-validator)

> **경고**이 섹션의 기술에는 TypeScript가 필요하며 앱이 바닐라 자바스크립트를 사용하여 작성된 경우 사용할 수 없습니다.

유효성 검사 기술의 대체 구현을 살펴 보겠습니다.

Nest는 [class-validator](https://github.com/typestack/class-validator) 라이브러리와 잘 작동합니다. 이 강력한 라이브러리를 사용하면 데코레이터 기반 유효성 검사를 사용할 수 있습니다. 데코레이터 기반 유효성 검사는 특히 처리된 속성의 `metatype`에 액세스할 수 있으므로 Nest의 **파이프** 기능과 결합할 때 매우 강력합니다. 시작하기 전에 필요한 패키지를 설치해야 합니다.

```bash
$ npm i --save class-validator class-transformer
```

이것들이 설치되면 `CreateCatDto` 클래스에 데코레이터 몇개를 추가할 수 있습니다. 여기에서 이 기법의 중요한 이점을 볼 수 있습니다.`CreateCatDto` 클래스는 Post 본문 객체에 대한 단일 소스로 남아 있습니다 (별도의 유효성 검사 클래스를 만들 필요가 없음).

create-cat.dto.tsJS

```typescript
import { IsString, IsInt } from 'class-validator';

export class CreateCatDto {
  @IsString()
  name: string;

  @IsInt()
  age: number;

  @IsString()
  breed: string;
}
```

> **힌트**클래스 유효성 검사기 데코레이터에 대한 자세한 내용은 [여기](https://github.com/typestack/class-validator#usage)를 참조하세요.

이제 이러한 주석을 사용하는 `ValidationPipe` 클래스를 만들 수 있습니다.

validation.pipe.tsJS

```typescript
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { validate } from 'class-validator';
import { plainToClass } from 'class-transformer';

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToClass(metatype, value);
    const errors = await validate(object);
    if (errors.length > 0) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metatype);
  }
}
```

> **알림**위에서 우리는 [class-transformer](https://github.com/typestack/class-transformer) 라이브러리를 사용했습니다. **class-validator** 라이브러리와 동일한 작성자가 만들었으며 결과적으로 서로 잘 어울립니다.

이 코드를 살펴보겠습니다. 먼저 `transform()` 메서드가 `async`로 표시되어 있습니다. Nest가 동기 및 **비동기** 파이프를 모두 지원하기 때문에 가능합니다. 일부 `class-validator` 유효성 검사가 [비동기화될 수 있음](https://github.com/typestack/class-validator#custom-validation-classes)(Promise 활용)때문에 이 메서드를 `async`로 만듭니다.

다음으로, 우리는 메타타입 필드 (`ArgumentMetadata`에서 이 멤버만 추출)를 `metatype` 매개변수로 추출하기 위해 디스트럭처링을 사용하고 있습니다. 이것은 전체 `ArgumentMetadata`를 가져온 다음 메타타입 변수를 할당하는 추가 명령문을 갖는 것에 대한 속기일 뿐입니다.

다음으로 헬퍼 함수 `toValidate()`를 확인합니다. 처리중인 현재 인수가 네이티브 자바스크립트 타입인 경우 유효성 검사 단계를 건너 뛰는 역할을 합니다(이러한 인수는 유효성 검사 데코레이터를 연결할 수 없으므로 유효성 검사 단계를 통해 실행할 이유가 없습니다).

다음으로 클래스 변환기 함수 `plainToClass()`를 사용하여 일반 자바스크립트 인수 객체를 타입이 지정된 객체로 변환하여 유효성 검사를 적용할 수 있습니다. 이 작업을 수행해야 하는 이유는 네트워크 요청에서 역직렬화될 때 들어오는 포스트(post) 본문 객체가 **아무 타입 정보도 가지고 있지 않기 때문입니다**(이것이 Express와 같은 기본 플랫폼이 작동하는 방식입니다). 클래스 유효성 검사기는 이전에 DTO에 대해 정의한 유효성 검사 데코레이터를 사용해야 하므로 들어오는 본문을 단순한 바닐라 객체가 아닌 적절하게 장식된 객체로 처리하기 위해 이 변환을 수행해야 합니다.

마지막으로 앞서 언급했듯이 이것은 **유효성 검사 파이프**이므로 변경되지 않은 값을 반환하거나 예외를 던집니다(throw).

마지막 단계는 `ValidationPipe`를 바인딩하는 것입니다. 파이프는 매개변수 범위, 메서드 범위, 컨트롤러 범위 또는 전역 범위일 수 있습니다. 앞서 Joi 기반 유효성 검사 파이프를 사용하여 메서드 수준에서 파이프를 바인딩하는 예를 보았습니다. 아래 예제에서는 파이프 인스턴스를 라우트 핸들러 `@Body()` 데코레이터에 바인딩하여 파이프가 포스트(post) 본문의 유효성을 검사하도록 호출합니다.

cats.controller.tsJS

```typescript
@Post()
async create(
  @Body(new ValidationPipe()) createCatDto: CreateCatDto,
) {
  this.catsService.create(createCatDto);
}
```

매개변수 범위 파이프는 유효성 검증 로직이 지정된 매개변수 하나만 관련될 때 유용합니다.

#### Global scoped pipes[#](https://docs.nestjs.kr/pipes#global-scoped-pipes)

`ValidationPipe`는 가능한 한 일반적으로 생성되었으므로 전체 애플리케이션의 모든 라우트 핸들러에 적용되도록 **전역 범위**(global-scoped) 파이프로 설정하여 완전한 유틸리티임을 실현할 수 있습니다.

main.tsJS

```typescript
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
bootstrap();
```

> **알림**[하이브리드 앱](https://docs.nestjs.kr/faq/hybrid-application)의 경우 `useGlobalPipes()` 메서드는 게이트웨이 및 마이크로서비스에 대한 파이프를 설정하지 않습니다. "표준"(비 하이브리드) 마이크로서비스 앱의 경우 `useGlobalPipes()`는 파이프를 전역으로 마운트합니다.

전역 파이프는 모든 컨트롤러 및 모든 라우트 핸들러에 대해 애플리케이션에서 사용됩니다.

의존성 주입과 관련하여 모듈 외부에서 등록된 전역 파이프(위의 예에서와 같이 `useGlobalPipes()` 사용)는 바인딩이 모듈 컨텍스트 외부에서 수행되었으므로 종속성을 주입할 수 없습니다. 이 문제를 해결하기 위해 다음 구성을 사용하여 **모든 모듈에서 직접** 전역 파이프를 설정할 수 있습니다.

app.module.tsJS

```typescript
import { Module } from '@nestjs/common';
import { APP_PIPE } from '@nestjs/core';

@Module({
  providers: [
    {
      provide: APP_PIPE,
      useClass: ValidationPipe,
    },
  ],
})
export class AppModule {}
```

> **힌트**이 접근방식을 사용하여 파이프에 대한 종속성 주입을 수행할 때 이 구성이 사용되는 모듈에 관계없이 파이프는 실제로 전역이라는 점에 유의하십시오. 어디에서해야 합니까? 파이프(위의 예에서는 `ValidationPipe`)가 정의된 모듈을 선택합니다. 또한 `useClass`가 커스텀 프로바이더 등록을 처리하는 유일한 방법은 아닙니다. [여기](https://docs.nestjs.kr/fundamentals/custom-providers)에서 자세히 알아보세요.

#### The built-in ValidationPipe[#](https://docs.nestjs.kr/pipes#the-built-in-validationpipe)

참고로 `ValidationPipe`는 Nest에서 즉시 제공되므로 일반 유효성 검사 파이프를 직접 빌드할 필요가 없습니다. 빌트인 `ValidationPipe`는 이 장에서 빌드한 샘플보다 더 많은 옵션을 제공합니다. 이 샘플은 커스텀 빌드 파이프의 메커니즘을 설명하기 위해 기본으로 유지되었습니다. 많은 예제와 함께 자세한 내용은 [여기](https://docs.nestjs.kr/techniques/validation)에서 찾을 수 있습니다.

#### Transformation use case[#](https://docs.nestjs.kr/pipes#transformation-use-case)

커스텀 파이프의 유일한 사용 사례는 유효성 검사가 아닙니다. 이 장의 시작부분에서 파이프가 입력 데이터를 원하는 형식으로 **변환**할 수도 있다고 언급했습니다. 이는 `transform` 함수에서 반환된 값이 인수의 이전값을 완전히 덮어쓰기 때문에 가능합니다.

이것이 언제 유용합니까? 때때로 클라이언트에서 전달된 데이터는 라우트 핸들러 메소드에 의해 적절하게 처리되기 전에 문자열을 정수로 변환하는 것과 같이 약간의 변경이 필요하다는 점을 고려하십시오. 또한 일부 필수 데이터 필드가 누락되었을 수 있으며 기본값을 적용하려고합니다. **변환 파이프**는 클라이언트 요청과 요청 핸들러 사이에 처리 기능을 삽입하여 이러한 기능을 수행할 수 있습니다.

다음은 문자열을 정수값으로 파싱하는 간단한 `ParseIntPipe`입니다.(위에서 언급했듯이 Nest에는 더 정교한 내장 `ParseIntPipe`가 있습니다. 이를 커스텀 변환 파이프의 간단한 예로 포함합니다).

### parse-int.pipe.ts

```typescript
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';

@Injectable()
export class ParseIntPipe implements PipeTransform<string, number> {
  transform(value: string, metadata: ArgumentMetadata): number {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed');
    }
    return val;
  }
}
```

We can then bind this pipe to the selected param as shown below:

그런 다음 이 파이프를 아래와 같이 선택한 매개변수에 바인딩할 수 있습니다.

```typescript
@Get(':id')
async findOne(@Param('id', new ParseIntPipe()) id) {
  return this.catsService.findOne(id);
}
```

Another useful transformation case would be to select an **existing user** entity from the database using an id supplied in the request:

또 다른 유용한 변환사례는 요청에 제공된 ID를 사용하여 데이터베이스에서 **기존 사용자** 항목을 선택하는 것입니다.

```typescript
@Get(':id')
findOne(@Param('id', UserByIdPipe) userEntity: UserEntity) {
  return userEntity;
}
```

We leave the implementation of this pipe to the reader, but note that like all other transformation pipes, it receives an input value (an `id`) and returns an output value (a `UserEntity` object). This can make your code more declarative and [DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself) by abstracting boilerplate code out of your handler and into a common pipe.

이 파이프의 구현은 독자에게 맡기지만 다른 모든 변환 파이프와 마찬가지로 입력값(`id`)을 받고 출력값(`UserEntity` 객체)을 반환합니다. 이렇게하면 핸들러에서 공통 파이프로 상용구 코드를 추상화하여 코드를 더 선언적이고 [DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself)하게 만들 수 있습니다.



## Providing defaults

`Parse*` pipes expect a parameter's value to be defined. They throw an exception upon receiving `null` or `undefined` values. To allow an endpoint to handle missing querystring parameter values, we have to provide a default value to be injected before the `Parse*` pipes operate on these values. The `DefaultValuePipe` serves that purpose. Simply instantiate a `DefaultValuePipe` in the `@Query()` decorator before the relevant `Parse*` pipe, as shown below:

`Parse*` 파이프는 매개변수 값이 정의될 것으로 예상합니다. `null` 또는 `undefined` 값을 받으면 예외가 발생합니다. 엔드포인트가 누락된 쿼리 문자열 매개변수 값을 처리할 수 있도록하려면 `Parse*` 파이프가 이러한 값에 대해 작동하기 전에 삽입할 기본값을 제공해야합니다. `DefaultValuePipe`는 그 목적에 부합합니다. 아래와 같이 관련 `Parse*` 파이프 앞에 `@Query()` 데코레이터에서 `DefaultValuePipe`를 인스턴스화하면됩니다.

```typescript
@Get()
async findAll(
  @Query('activeOnly', new DefaultValuePipe(false), ParseBoolPipe) activeOnly: boolean,
  @Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number,
) {
  return this.catsService.findAll({ activeOnly, page });
}
```

### 

#### 출처

> https://docs.nestjs.com/pipes
>
> https://docs.nestjs.kr/pipes